---
interface Slide {
  title: string;
  description: string;
  link?: string;
  linkText?: string;
  bgClass?: string;
  bgImage?: string;
}

interface Props {
  slides: Slide[];
}

const { slides } = Astro.props;
---

<div class="hero-carousel" id="heroCarousel">
  <div class="carousel-slides">
    {slides.map((slide, index) => (
      <div 
        class={`carousel-slide ${slide.bgClass || 'slide-default'}`}
        style={slide.bgImage ? `background-image: url(${slide.bgImage}); background-size: cover; background-position: center;` : ''}
      >
        <div>
          <h2>{slide.title}</h2>
          <p>{slide.description}</p>
          {slide.link && (
            <a href={slide.link} class="btn btn-secondary">{slide.linkText || '了解更多'}</a>
          )}
        </div>
      </div>
    ))}
  </div>
  
  <button class="carousel-arrow prev" aria-label="上一張">❮</button>
  <button class="carousel-arrow next" aria-label="下一張">❯</button>
  
  <div class="carousel-dots">
    {slides.map((_, index) => (
      <button class={`carousel-dot ${index === 0 ? 'active' : ''}`} data-index={index} aria-label={`第 ${index + 1} 張`}></button>
    ))}
  </div>
</div>

<script>
  const carousel = document.getElementById('heroCarousel');
  if (carousel) {
    const slidesContainer = carousel.querySelector('.carousel-slides') as HTMLElement;
    const dots = carousel.querySelectorAll('.carousel-dot');
    const prevBtn = carousel.querySelector('.prev');
    const nextBtn = carousel.querySelector('.next');
    const totalSlides = dots.length;
    let currentIndex = 0;
    let autoPlayInterval: number;

    function goToSlide(index: number) {
      currentIndex = (index + totalSlides) % totalSlides;
      slidesContainer.style.transform = `translateX(-${currentIndex * 100}%)`;
      dots.forEach((dot, i) => {
        dot.classList.toggle('active', i === currentIndex);
      });
    }

    function nextSlide() {
      goToSlide(currentIndex + 1);
    }

    function prevSlide() {
      goToSlide(currentIndex - 1);
    }

    function startAutoPlay() {
      autoPlayInterval = setInterval(nextSlide, 5000);
    }

    function stopAutoPlay() {
      clearInterval(autoPlayInterval);
    }

    // Event listeners
    prevBtn?.addEventListener('click', () => { prevSlide(); stopAutoPlay(); startAutoPlay(); });
    nextBtn?.addEventListener('click', () => { nextSlide(); stopAutoPlay(); startAutoPlay(); });
    dots.forEach((dot, index) => {
      dot.addEventListener('click', () => { goToSlide(index); stopAutoPlay(); startAutoPlay(); });
    });

    // Touch/swipe support
    let touchStartX = 0;
    carousel.addEventListener('touchstart', (e) => { touchStartX = e.touches[0].clientX; });
    carousel.addEventListener('touchend', (e) => {
      const diff = touchStartX - e.changedTouches[0].clientX;
      if (Math.abs(diff) > 50) {
        diff > 0 ? nextSlide() : prevSlide();
        stopAutoPlay(); startAutoPlay();
      }
    });

    // Start autoplay
    startAutoPlay();
    carousel.addEventListener('mouseenter', stopAutoPlay);
    carousel.addEventListener('mouseleave', startAutoPlay);
  }
</script>
